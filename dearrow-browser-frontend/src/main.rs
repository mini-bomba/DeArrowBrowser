/* This file is part of the DeArrow Browser project - https://github.com/mini-bomba/DeArrowBrowser
*
*  Copyright (C) 2023-2024 mini_bomba
*  
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU Affero General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU Affero General Public License for more details.
*
*  You should have received a copy of the GNU Affero General Public License
*  along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
use std::rc::Rc;
use dearrow_browser_api::unsync::StatusResponse;
use gloo_console::error;
use reqwest::Url;
use thumbnails::components::ThumbgenProvider;
use yew::prelude::*;
use yew_hooks::{use_async_with_options, UseAsyncOptions, use_interval};
use yew_router::prelude::*;
use web_sys::window;

pub mod hooks;
pub mod utils;
pub mod components;
pub mod contexts;
pub mod pages;
pub mod thumbnails;
use contexts::*;
use pages::*;

#[function_component]
fn App() -> Html {
    let window_context = use_memo((), |()| {
        let window = window().expect("window should exist");
        WindowContext {
            origin: Url::parse(
                window.location().origin().expect("window.location.origin should exist").as_str()
            ).expect("window.location.origin should be a valid URL"),
            logo_url: window.document()
                .and_then(|d| d.query_selector("link[rel=icon]").ok().flatten())
                .and_then(|el| el.get_attribute("href"))
                .map(AttrValue::from),
        }
    });
    let update_clock = use_state(|| UpdateClock(false));

    let status = {
        let window_context = window_context.clone();
        use_async_with_options::<_, Rc<StatusResponse>, Rc<anyhow::Error>>(async move { 
            async { Ok(
                reqwest::get(window_context.origin.join("/api/status")?).await?
                    .json().await?
            )}.await.map(Rc::new).map_err(Rc::new).inspect_err(|err| error!(format!("Failed to fetch status: {err:?}")))
        }, UseAsyncOptions::enable_auto())
    };
    {
        let status = status.clone();
        let update_clock = update_clock.clone();
        use_interval(move || {
            update_clock.set(UpdateClock(!update_clock.0));
            status.run();
        }, 60*1000);
    }

    html! {
        <ContextProvider<Rc<WindowContext>> context={window_context}>
        <ContextProvider<StatusContext> context={status.data.clone()}>
        <ThumbgenProvider>
        <ContextProvider<UpdateClock> context={*update_clock}>
            <BrowserRouter>
                <Switch<MainRoute> render={render_main_route} />
            </BrowserRouter>
        </ContextProvider<UpdateClock>>
        </ThumbgenProvider>
        </ContextProvider<StatusContext>>
        </ContextProvider<Rc<WindowContext>>>
    }
}

fn main() {
    yew::Renderer::<App>::new().render();
}

pub mod built_info {
    // Contents generated by buildscript, using built
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}
