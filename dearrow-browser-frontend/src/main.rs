use std::rc::Rc;
use dearrow_browser_api::StatusResponse;
use reqwest::Url;
use strum::IntoStaticStr;
use yew::prelude::*;
use yew_hooks::{use_async_with_options, UseAsyncOptions, use_interval};
use yew_router::prelude::*;
use web_sys::window;

pub mod hooks;
pub mod utils;
pub mod components;
pub mod contexts;
mod pages;
use components::modal_renderer::ModalRenderer;
use contexts::*;

use crate::components::header_footer::*;
use crate::pages::*;

#[derive(Clone, Routable, PartialEq, IntoStaticStr)]
enum Route {
    #[at("/")]
    Home,
    #[at("/unverified")]
    Unverified,
    #[at("/video_id/:id")]
    Video { id: String },
    #[at("/user_id/:id")]
    User { id: String },
    #[at("/wip")]
    NotImplemented,
    #[not_found]
    #[at("/404")]
    NotFound,
}

#[function_component]
fn App() -> Html {
    let window_context = use_memo((), |_| {
        let window = window().expect("window should exist");
        WindowContext {
            origin: Url::parse(
                window.location().origin().expect("window.location.origin should exist").as_str()
            ).expect("window.location.origin should be a valid URL"),
            logo_url: window.document()
                .and_then(|d| d.query_selector("link[rel=icon]").ok().flatten())
                .and_then(|el| el.get_attribute("href"))
                .map(AttrValue::from),
        }
    });
    let update_clock = use_state(|| UpdateClock(false));

    let status = {
        let window_context = window_context.clone();
        use_async_with_options::<_, Rc<StatusResponse>, Rc<anyhow::Error>>(async move { 
            async { Ok(
                reqwest::get(window_context.origin.join("/api/status")?).await?
                    .json().await?
            )}.await.map(Rc::new).map_err(Rc::new)
        }, UseAsyncOptions::enable_auto())
    };
    {
        let status = status.clone();
        let update_clock = update_clock.clone();
        use_interval(move || {
            update_clock.set(UpdateClock(!update_clock.0));
            status.run();
        }, 60*1000);
    }

    html! {
        <ContextProvider<Rc<WindowContext>> context={window_context}>
        <ContextProvider<StatusContext> context={status.data.clone()}>
        <ContextProvider<UpdateClock> context={*update_clock}>
            <BrowserRouter>
                <Switch<Route> render={render_route} />
            </BrowserRouter>
        </ContextProvider<UpdateClock>>
        </ContextProvider<StatusContext>>
        </ContextProvider<Rc<WindowContext>>>
    }
}

fn render_route(route: Route) -> Html {
    let document = window().expect("window should exist")
        .document().expect("document should exist");
    document.set_title(match &route {
        Route::Home => "DeArrow Browser".to_string(),
        Route::Unverified => "Unverified titles - DeArrow Browser".to_string(),
        Route::NotFound => "Page not found - DeArrow Browser".to_string(),
        Route::NotImplemented => "Not implemented - DeArrow Browser".to_string(),
        Route::Video { ref id } => format!("VideoID {id} - DeArrow Browser"),
        Route::User { ref id } => format!("UserID {id} - Dearrow Browser"),
    }.as_str());
    let route_html = match route {
        Route::Home => html! {<HomePage/>},
        Route::Unverified => html! {<UnverifiedPage/>},
        Route::Video { ref id } => html! {<VideoPage videoid={id.clone()} />},
        Route::User { ref id } => html! {<UserPage userid={id.clone()} />},
        Route::NotFound => html! {
            <>
                <h2>{"404 - Not found"}</h2>
                <h3>{"Looks like you've entered an invalid URL"}</h3>
                <Link<Route> to={Route::Home}>{"Return to home page"}</Link<Route>>
            </>
        },
        Route::NotImplemented => html! {
            <>
                <h2>{"Not implemented"}</h2>
                <h3>{"This feature is not implemented yet"}</h3>
                <Link<Route> to={Route::Home}>{"Return to home page"}</Link<Route>>
            </>
        },
    };
    let route_name: &'static str = (&route).into();
    html! {
        <ModalRenderer>
            <Header />
            <div id="content" data-route={route_name}>
                {route_html}
            </div>
            <Footer />
        </ModalRenderer>
    }
}

fn main() {
    yew::Renderer::<App>::new().render();
}

pub mod built_info {
    // Contents generated by buildscript, using built
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}
